/*vec3 calcDirLight(DirectionalLight l) {

	vec3 norm = normalize(fs_in.normal0);
	vec3 lightDir = normalize(-l.direction);
	float diff = max(dot(norm, lightDir), 0.0);
	vec3 reflectDir = reflect(-lightDir, norm);

	float spec = pow(max(dot(normalize(viewPos - fs_in.position0), reflectDir), 0.0), material.specPow);
	vec3 diffuse = l.light.diffuse * diff * vec3(texture(material.diffuse, fs_in.texture0));
	vec3 specular = l.light.specular * spec * vec3(texture(material.specular, fs_in.texture0));
    vec3 ambient  = l.light.ambient  * vec3(texture(material.diffuse, fs_in.texture0));

	return ambient + diffuse + specular;
}

vec3 calcPointLight(PointLight l) {
	vec3 norm = normalize(fs_in.normal0);
    vec3 viewDir = normalize(viewPos - fs_in.position0);

	vec3 lightDir = normalize(l.position - fs_in.position0);

	float diff = max(dot(norm, lightDir), 0.0);

	vec3 reflectDir = reflect(-lightDir, norm);
	float spec = pow(max(dot(viewDir, reflectDir), 0.0), material.specPow);
    
    float distance = length(l.position - fs_in.position0);
    float attenuation = 1.0 / (l.attenuation.constant + l.attenuation.linear * distance + l.attenuation.quadratic * (distance * distance));    
    
    vec3 ambient = l.light.ambient * vec3(texture(material.diffuse, fs_in.texture0));
    vec3 diffuse = l.light.diffuse * diff * vec3(texture(material.diffuse, fs_in.texture0));
    vec3 specular = l.light.specular * spec * vec3(texture(material.specular, fs_in.texture0));
   
	ambient *= attenuation;
    diffuse *= attenuation;
    specular *= attenuation;
    return ambient + diffuse + specular;
}

vec3 calcSpotLight(SpotLight l) {
	vec3 norm = normalize(fs_in.normal0);
    vec3 viewDir = normalize(viewPos - fs_in.position0);
	vec3 lightDir = normalize(l.position - fs_in.position0);

    float diff = max(dot(norm, lightDir), 0.0);
    vec3 reflectDir = reflect(-lightDir, norm);

    float spec = pow(max(dot(viewDir, reflectDir), 0.0), material.specPow);
    float distance = length(l.position - fs_in.position0);
    float attenuation = 1.0 / (l.attenuation.constant + l.attenuation.linear * distance + l.attenuation.quadratic * (distance * distance));    
    
	float theta = dot(lightDir, normalize(-l.direction)); 
    float epsilon = l.cutOff - l.outerCutOff;
    float intensity = clamp((theta - l.outerCutOff) / epsilon, 0.0, 1.0);
    
	vec3 ambient = l.light.ambient * vec3(texture(material.diffuse, fs_in.texture0));
	vec3 diffuse = l.light.diffuse * diff * vec3(texture(material.diffuse, fs_in.texture0));
    vec3 specular = l.light.specular * spec * vec3(texture(material.specular, fs_in.texture0));
    diffuse *= attenuation * intensity;
    specular *= attenuation * intensity;
	ambient *= attenuation * intensity;

    return ambient + diffuse + specular;
}

void LightingPass() {
	vec3 color = calcDirLight(dirLight);
	for (int i = 0; i < numSpot; i++) {
		color += calcSpotLight(spotLights[i]);
	}
	for (int i = 0; i < numPoint; i++) {
		color += calcSpotLight(pointLights[i]);
	}
	fragColor = fragColor * color;
} */

void main() {
	Fragment();
	//LightingPass();
}

